<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aloha,I&#39;m Nick</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://u.lovemma.cn/"/>
  <updated>2020-07-19T01:31:03.471Z</updated>
  <id>http://u.lovemma.cn/</id>
  
  <author>
    <name>Nick Deng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rxjs learning</title>
    <link href="http://u.lovemma.cn/passages/Rxjs/"/>
    <id>http://u.lovemma.cn/passages/Rxjs/</id>
    <published>2020-07-19T01:17:49.000Z</published>
    <updated>2020-07-19T01:31:03.471Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解rxjs的操作符, 特别是开发中常用的～</p><a id="more"></a><p><img src="http://qiniu.lovemma.cn/wechat/rxjs.png" alt="mergeMap"></p><h2 id="RxJS最佳实践"><a href="#RxJS最佳实践" class="headerlink" title="RxJS最佳实践"></a>RxJS最佳实践</h2><p>来自官网～</p><blockquote><p>Observable对象可以简化输入提示建议的实现方法，典型的输入提示完成一系列的独立的任务。</p></blockquote><ol><li>从输入中监听数据。</li><li>移除输入值前后的空白字符，并确认它达到了最小长度。</li><li>防抖（这样才能防止连续按键时每次都发起API请求，而应该等到按键出现停顿时才发起）。</li><li>如果输入的值没有发生变化，则不要发起请求（比如按下某个字符，然后快速按退格）。</li><li>如果已发出的AJAX请求的结果会因为后续的修改变得无效，那就取消它。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; debounceTime, distinctUntilChanged, filter, map, switchMap &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serachBox = <span class="built_in">document</span>.getElementById(<span class="string">'search-box'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> typeahead$ = fromEvent(searchBox, <span class="string">'input'</span>).pipe(</span><br><span class="line">   map(<span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> (e.target <span class="keyword">as</span> HTMLInputElement).value),</span><br><span class="line">   filter(<span class="function"><span class="params">text</span> =&gt;</span> text.length &gt; <span class="number">2</span>),</span><br><span class="line">   debounceTime(<span class="number">10</span>),</span><br><span class="line">   distinctUntilChanged(),</span><br><span class="line">   switchMap(<span class="function"><span class="params">()</span> =&gt;</span> ajax(<span class="string">'/api/endpoint'</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">typeahead$.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// Handle the data from the API</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Rx实现斐波拉契数列"><a href="#Rx实现斐波拉契数列" class="headerlink" title="Rx实现斐波拉契数列"></a>Rx实现斐波拉契数列</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; interval &#125; = Rx;</span><br><span class="line"><span class="keyword">const</span> &#123; scan, pluck, groupBy &#125; = RxOperators;</span><br><span class="line"></span><br><span class="line">interval(<span class="number">1000</span>).pipe(</span><br><span class="line">  scan(</span><br><span class="line">    (&#123; secondLast, last &#125;) =&gt; (&#123;</span><br><span class="line">      secondLast: last,</span><br><span class="line">      last: last + secondLast</span><br><span class="line">    &#125;),</span><br><span class="line">    &#123; <span class="attr">secondLast</span>: <span class="number">0</span>, <span class="attr">last</span>: <span class="number">1</span> &#125;</span><br><span class="line">  ),</span><br><span class="line">  pluck(<span class="string">"secondLast"</span>),</span><br><span class="line">  groupBy(<span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.log10(n)))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.lovemma.cn/wechat/rx-fib.png" alt="RxFib"></p><p><a href="http://angular.ink/#/rxjs/operators" target="_blank" rel="noopener">分类整理</a></p><h2 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h2><h3 id="from、of"><a href="#from、of" class="headerlink" title="from、of"></a>from、of</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">of</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// 记得任何可列举的参数都可以用喔，也就是说像 Set, WeakSet, Iterator 等都可以当作参数！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入Promise</span></span><br><span class="line"><span class="keyword">var</span> source = <span class="keyword">from</span>(<span class="keyword">new</span> <span class="built_in">Promise</span>(resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'Hello RxJS!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'complete'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello RxJS!</span></span><br><span class="line"><span class="comment">// complete!</span></span><br></pre></td></tr></table></figure><p>如果我们传入 Promise 物件实例，当正常回传时，就会被送到 next，并立即送出完成通知，如果有错误则会送到 error。</p><h3 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h3><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>这个可以在建立轮询时使用，让我们不断地发 request 来更新画面。</p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>当 timer 有两个参数时，第一个参数代表要发出第一个值的等待时间(ms)，第二个参数代表第一次之后发送值的间隔时间，所以上面这段程式码会先等一秒送出 0 之后每五秒送出 1, 2, 3, 4…。<br>timer 第一个参数除了可以是数值(Number)之外，也可以是<strong>日期(Date)</strong>，就会等到指定的时间在发送第一个值。<br>timer也可以只接受一个参数，等待参数时间后结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; timer &#125; = Rx;</span><br><span class="line"><span class="comment">//const &#123;  &#125; = RxOperators;</span></span><br><span class="line"></span><br><span class="line">timer(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0;</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><h2 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h3 id="mapTo"><a href="#mapTo" class="headerlink" title="mapTo"></a>mapTo</h3><h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><h3 id="buffer-缓存元素"><a href="#buffer-缓存元素" class="headerlink" title="buffer 缓存元素"></a>buffer 缓存元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; timer &#125; = Rx;</span><br><span class="line"><span class="keyword">const</span> &#123; take, buffer &#125; = RxOperators;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> os1$ = timer(<span class="number">0</span>, <span class="number">1000</span>).pipe(take(<span class="number">5</span>));</span><br><span class="line"><span class="keyword">const</span> os2$ = timer(<span class="number">2000</span>, <span class="number">2000</span>).pipe(take(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">os1$.pipe(buffer(os2$))<span class="comment">// 0 1 2 3</span></span><br></pre></td></tr></table></figure><h3 id="bufferTime"><a href="#bufferTime" class="headerlink" title="bufferTime"></a>bufferTime</h3><p>一段时间内触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>);</span><br><span class="line"><span class="keyword">const</span> click = Rx.Observable.fromEvent(button, <span class="string">'click'</span>)</span><br><span class="line"><span class="keyword">const</span> example = click</span><br><span class="line">                .bufferTime(<span class="number">500</span>)</span><br><span class="line">                .filter(<span class="function"><span class="params">arr</span> =&gt;</span> arr.length &gt;= <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'success'</span>); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这裡我们只有在 500 毫秒内连点两下，才能成功印出 ‘success’，这个功能在某些特殊的需求中非常的好用，也能用在批次处理来降低 request 传送的次数！</p><h3 id="bufferCount"><a href="#bufferCount" class="headerlink" title="bufferCount"></a>bufferCount</h3><h3 id="concatMap-——-主流缓存，从流结束，立即响应"><a href="#concatMap-——-主流缓存，从流结束，立即响应" class="headerlink" title="concatMap —— 主流缓存，从流结束，立即响应"></a>concatMap —— 主流缓存，从流结束，立即响应</h3><p><code>Observable&lt;Observable&lt;T&gt;&gt;</code> 二维 Observable</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; timer &#125; = Rx;</span><br><span class="line"><span class="keyword">const</span> &#123; take, concatMap &#125; = RxOperators;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> os1$ = timer(<span class="number">0</span>,<span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">os1$.pipe(concatMap(<span class="function"><span class="params">()</span> =&gt;</span> timer(<span class="number">0</span>,<span class="number">1000</span>).pipe(take(<span class="number">5</span>)), (s1, s2)=&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;s1&#125;</span> - <span class="subst">$&#123;s2&#125;</span>`</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Time line</span></span><br><span class="line"><span class="comment">// 0-------------------1------------------</span></span><br><span class="line"><span class="comment">// 0---1---2---3---4---0---1---2---3---4--</span></span><br><span class="line"><span class="comment">// 0-0 0-1 0-2 0-3 0-4 1-0 1-1 1-2 1-3 1-4</span></span><br></pre></td></tr></table></figure><blockquote><p>从结果可以看到，用concatMap的时候，虽然在<strong>从流还没有结束的时候</strong>，<strong>主流还在发射数据</strong>，主流会先把发射的<strong>数据缓存</strong>起来，等从流结束后<strong>立即响应主流的数据</strong>从而引发新一轮的从流发射，这有些类似与js的消息队列机制。所以我们看到它的输出流响应是连续的。</p></blockquote><h3 id="switch-处理最新"><a href="#switch-处理最新" class="headerlink" title="switch 处理最新"></a>switch 处理最新</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> click = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">'click'</span>);</span><br><span class="line"><span class="keyword">var</span> source = click.map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.switch();</span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>switch 最重要的就是他会在新的 observable 送出后直接处理新的 observable 不管前一个 observable 是否完成，每当有新的 observable 送出就会直接把旧的 observable 退订(unsubscribe)，<strong>永远只处理最新的 observable!</strong></p><h3 id="switchMap-——-主流切断"><a href="#switchMap-——-主流切断" class="headerlink" title="switchMap —— 主流切断"></a>switchMap —— 主流切断</h3><p>map 加上 switch 简化的写法<br>主流-从流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mainstream = Rx.Observable.interval(<span class="number">500</span>);<span class="comment">// 主流</span></span><br><span class="line">mainstream.switchMap(<span class="function">(<span class="params">x</span>) =&gt;</span> Rx.Observable.interval(<span class="number">200</span>).take(<span class="number">5</span>));<span class="comment">// 从流</span></span><br></pre></td></tr></table></figure><blockquote><p>用switchMap的时候，从流每次只能发射2个数据0-1，<br>这是因为<strong>主流每发射一次触发了从流的发射</strong>，<br>但是在从流发射的过程中，如果主流又一次发射了数据，<br>switchMap会截断上一次的从流，响应本次的主流，<br>从而开启新的一段的从流发射。</p></blockquote><h2 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><h3 id="first"><a href="#first" class="headerlink" title="first"></a>first</h3><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>略过前几个送出元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.skip(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5...</span></span><br></pre></td></tr></table></figure><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>顾名思义就是取前几个元素后就结束.</p><h3 id="takeUtil"><a href="#takeUtil" class="headerlink" title="takeUtil"></a>takeUtil</h3><p>takeUntil 很常使用到，他可以在某件事情发生时，让一个 observable 直送出 完成(complete)讯息.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> click = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">'click'</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.takeUntil(click);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// complete (点击body了</span></span><br></pre></td></tr></table></figure><h3 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h3><p>倒过来取最后几个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.takeLast(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><h3 id="debounceTime"><a href="#debounceTime" class="headerlink" title="debounceTime"></a>debounceTime</h3><h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><p>注意：一开始会执行一次，等到有元素被送出就会沈默一段时间，等到时间过了又会开放发送元素。</p><h3 id="throttleTime"><a href="#throttleTime" class="headerlink" title="throttleTime"></a>throttleTime</h3><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([&#123; <span class="attr">value</span>: <span class="string">'a'</span>&#125;, &#123; <span class="attr">value</span>: <span class="string">'b'</span> &#125;, &#123; <span class="attr">value</span>: <span class="string">'c'</span> &#125;, &#123; <span class="attr">value</span>: <span class="string">'a'</span> &#125;, &#123; <span class="attr">value</span>: <span class="string">'c'</span> &#125;])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">300</span>), (x, y) =&gt; x);</span><br><span class="line"><span class="keyword">var</span> example = source.distinct(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.value</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &#123;value: "a"&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: "b"&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: "c"&#125;</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>distinct 可以传入第二个参数 flushes observable 用来清除暂存的资料,其实 flushes observable 就是在送出元素时，会把 distinct 的暂存清空，所以之后的暂存就会从头来过，这样就不用担心暂存的 Set 越来愈大的问题</p><h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h3><p>distinctUntilChanged 跟 distinct 一样会把相同的元素过滤掉，但 distinctUntilChanged 只会跟最后一次送出的元素比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">300</span>), (x, y) =&gt; x);</span><br><span class="line"><span class="keyword">var</span> example = source.distinctUntilChanged()</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><p>这裡 distinctUntilChanged 只会暂存一个元素，并在收到元素时跟暂存的元素比对，如果一样就不送出，如果不一样就把暂存的元素换成刚接收到的新元素并送出。</p><h2 id="结合操作符"><a href="#结合操作符" class="headerlink" title="结合操作符"></a>结合操作符</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>可以把多个 observable 实例合併成一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> source2 = Rx.Observable.of(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> source3 = Rx.Observable.of(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">var</span> example = source.concat(source2, source3);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// complete</span></span><br></pre></td></tr></table></figure><h3 id="concatAll-执行完上一个，才会继续执行"><a href="#concatAll-执行完上一个，才会继续执行" class="headerlink" title="concatAll 执行完上一个，才会继续执行"></a>concatAll 执行完上一个，才会继续执行</h3><p>concatAll 最重要的重点就是他会处理完前一个 observable 才会在处理下一个 observable<br>当我们用 concatAll 之后会把二维的 observable 摊平成一维的 observable，但 concatAll 会一个一个处理，一定是等前一个 observable 完成(complete)才会处理下一个 observable。<br>实例中，因为现在送出 observable <strong>是无限的永远不会完成(complete)</strong>，就导致他永远不会处理第二个送出的 observable!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> click = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">'click'</span>);</span><br><span class="line"><span class="keyword">var</span> source = click.map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.concatAll();</span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// (点击后)</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5 ...</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click  : ---------c-c------------------c--..</span><br><span class="line">        map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>))</span><br><span class="line">source : ---------o-o------------------o--..</span><br><span class="line">                   \ \</span><br><span class="line">                    \ ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>---<span class="number">-3</span>---<span class="number">-4</span>--...</span><br><span class="line">                     ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>---<span class="number">-3</span>---<span class="number">-4</span>--...</span><br><span class="line">                     concatAll()</span><br><span class="line">example: ---------------<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>---<span class="number">-3</span>---<span class="number">-4</span>--..</span><br></pre></td></tr></table></figure><h3 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h3><p>可以在 observable 的一开始塞要发送的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> example = source.startWith(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3...</span></span><br></pre></td></tr></table></figure><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>merge 把多个 observable 同时处理<br>merge 之后的 example 在时间序上同时在跑 source 与 source2，当两件事情同时发生时，会同步送出资料(被 merge 的在后面)，当两个 observable 都结束时才会真的结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source : ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>|</span><br><span class="line">source2: -<span class="number">-0</span>-<span class="number">-1</span>-<span class="number">-2</span>-<span class="number">-3</span>-<span class="number">-4</span>-<span class="number">-5</span>|</span><br><span class="line">            merge()</span><br><span class="line">example: -<span class="number">-0</span><span class="number">-01</span>-<span class="number">-21</span><span class="number">-3</span>--(<span class="number">24</span>)-<span class="number">-5</span>|</span><br></pre></td></tr></table></figure><h3 id="mergeAll-并行处理"><a href="#mergeAll-并行处理" class="headerlink" title="mergeAll 并行处理"></a>mergeAll 并行处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> click = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">'click'</span>);</span><br><span class="line"><span class="keyword">var</span> source = click.map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.mergeAll();</span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click  : ---------c-c------------------c--..</span><br><span class="line">        map(<span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>))</span><br><span class="line">source : ---------o-o------------------o--..</span><br><span class="line">                   \ \                  \---<span class="number">-0</span>---<span class="number">-1</span>--...</span><br><span class="line">                    \ ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>---<span class="number">-3</span>---<span class="number">-4</span>--...</span><br><span class="line">                     ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>---<span class="number">-3</span>---<span class="number">-4</span>--...</span><br><span class="line">                     <span class="keyword">switch</span>()</span><br><span class="line">example: ---------------<span class="number">-00</span>--<span class="number">-11</span>--<span class="number">-22</span>--<span class="number">-33</span>---(<span class="number">04</span>)<span class="number">4</span>--...</span><br></pre></td></tr></table></figure><p>mergeAll 可以传入一个数值，这个数值代表他可以同时处理的 observable 数量,如果我们传入 1 其行为就会跟 concatAll 是一模一样的，这点在原始码可以看到他们是完全相同的。</p><h3 id="mergeMap-——-实时响应，永不遗漏"><a href="#mergeMap-——-实时响应，永不遗漏" class="headerlink" title="mergeMap —— 实时响应，永不遗漏"></a>mergeMap —— 实时响应，永不遗漏</h3><p>map 加上 mergeAll</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; timer, <span class="keyword">of</span> &#125; = Rx;</span><br><span class="line"><span class="keyword">const</span> &#123; take, mergeMap, mapTo &#125; = RxOperators;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source$ = timer(<span class="number">0</span>, <span class="number">2000</span>).pipe(mapTo(<span class="string">'hello'</span>),take(<span class="number">5</span>))</span><br><span class="line">source$.pipe(mergeMap(<span class="function"><span class="params">val</span> =&gt;</span> <span class="keyword">of</span>(<span class="string">`<span class="subst">$&#123;val&#125;</span> - world`</span>)))</span><br></pre></td></tr></table></figure><h3 id="flatMap-——-实时响应，永不遗漏"><a href="#flatMap-——-实时响应，永不遗漏" class="headerlink" title="flatMap —— 实时响应，永不遗漏"></a>flatMap —— 实时响应，永不遗漏</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="keyword">var</span> mainstream= Rx.Observable.interval(<span class="number">500</span>);</span><br><span class="line">mainstream.flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> Rx.Observable.interval(<span class="number">200</span>).take(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><blockquote><p>从结果可以看出来，flatMap/mergeMap会实时的响应主流中发射的每一个数据<br>，它既不会忽略也不会缓存，这就导致主流中数据对应的从流产生了叠加。</p></blockquote><h3 id="exhaustMap-——-主流等待，缓缓执行"><a href="#exhaustMap-——-主流等待，缓缓执行" class="headerlink" title="exhaustMap —— 主流等待，缓缓执行"></a>exhaustMap —— 主流等待，缓缓执行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mainstream= Rx.Observable.interval(<span class="number">500</span>);</span><br><span class="line">mainstream.exhaustMap(<span class="function">(<span class="params">x</span>) =&gt;</span> Rx.Observable.interval(<span class="number">200</span>).take(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><blockquote><p>从结果可以看出，exhaustMap在<strong>从流还没有结束</strong>的时候如果主流仍然有数据在发射，<br>它会<strong>忽略此时主流</strong>发射的数据，而在从流结束以后才会去响应主流中发射的数据。</p></blockquote><h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><p>combineLatest 很常用在运算多个因子的结果，例如最常见的 BMI 计算，我们身高变动时就拿上一次的体重计算新的 BMI，当体重变动时则拿上一次的身高计算 BMI，这就很适合用 combineLatest 来处理！<br><a href="https://ithelp.ithome.com.tw/articles/10187638" target="_blank" rel="noopener">learning combineLastest</a></p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip 会把各个 observable 相同顺位送出的值传入 callback，这很常拿来做 demo 使用，比如我们想要间隔 100ms 送出 ‘h’, ‘e’, ‘l’, ‘l’, ‘o’，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">var</span> source2 = Rx.Observable.interval(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.zip(source2, (x, y) =&gt; x);</span><br></pre></td></tr></table></figure><p>source : (hello)|<br>source2: -0-1-2-3-4-…<br>        zip(source2, (x, y) =&gt; x)<br>example: -h-e-l-l-o|</p><h3 id="withLatestFrom"><a href="#withLatestFrom" class="headerlink" title="withLatestFrom"></a>withLatestFrom</h3><p>withLatestFrom 会在 main 送出值的时候执行 callback, 但请注意如果 main 送出值时 some 之前没有送出过任何值 callback 仍然不会执行！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> main = Rx.Observable.from(<span class="string">'hello'</span>).zip(Rx.Observable.interval(<span class="number">500</span>), (x, y) =&gt; x);</span><br><span class="line"><span class="keyword">var</span> some = Rx.Observable.from([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]).zip(Rx.Observable.interval(<span class="number">300</span>), (x, y) =&gt; x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = main.withLatestFrom(some, (x, y) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> y === <span class="number">1</span> ? x.toUpperCase() : x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>main   : —-h—-e—-l—-l—-o|<br>some   : –0–1–0–0–0–1|</p><p>withLatestFrom(some, (x, y) =&gt;  y === 1 ? x.toUpperCase() : x);</p><p>example: —-h—-e—-l—-L—-O|</p><h2 id="实用操作符"><a href="#实用操作符" class="headerlink" title="实用操作符"></a>实用操作符</h2><h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p>UI 操作<br><a href="https://jsbin.com/sotutevali/edit?html,css,js,output" target="_blank" rel="noopener">demo</a><br>delay 可以延迟 observable 一开始发送元素的时间点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source.delay(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>source : –0–1–2–3–4|<br>        delay(500)<br>example: ——-0–1–2–3–4|</p><h3 id="delayWhen"><a href="#delayWhen" class="headerlink" title="delayWhen"></a>delayWhen</h3><p> UI 操作<br>delayWhen 的作用跟 delay 很像，最大的差别是 delayWhen 可以影响每个元素，而且需要传一个 callback 并回传一个 observable</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">              .delayWhen(</span><br><span class="line">                  x =&gt; Rx.Observable.empty().delay(<span class="number">100</span> * x * x)</span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="错误处理操作符"><a href="#错误处理操作符" class="headerlink" title="错误处理操作符"></a>错误处理操作符</h2><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>catch 是很常见的非同步错误处理方法，在 RxJS 中也能够直接用 catch 来处理错误，在 RxJS 中的 catch 可以回传一个 observable 来送出新的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="number">2</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), (x,y) =&gt; x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">                .catch(<span class="function"><span class="params">error</span> =&gt;</span> Rx.Observable.of(<span class="string">'h'</span>));</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>source : —-a—-b—-c—-d—-2|<br>        map(x =&gt; x.toUpperCase())<br>         —-a—-b—-c—-d—-X|<br>        catch(error =&gt; Rx.Observable.of(‘h’))<br>example: —-A—-B—-C—-D—-h|</p><p>遇到错误后也可以让Observable完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> Rx.Observable.empty())</span><br></pre></td></tr></table></figure><p>另外 catch 的 callback 能接收第二个参数，这个参数会接收当前的 observalbe，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="number">2</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), (x,y) =&gt; x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">                .catch(<span class="function">(<span class="params">error, obs</span>) =&gt;</span> obs);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里会变成一个死循环</p><h3 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h3><p>通常这种无限的 retry 会放在即时同步的重新连接，让我们在连线断掉后，不断的尝试，同时也可以设置重连的次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="number">2</span>])</span><br><span class="line">            .zip(Rx.Observable.interval(<span class="number">500</span>), (x,y) =&gt; x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = source</span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">                .retry(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">example.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// Error: TypeError: x.toUpperCase is not a function</span></span><br></pre></td></tr></table></figure><h3 id="retryWhen"><a href="#retryWhen" class="headerlink" title="retryWhen"></a>retryWhen</h3><p>retryWhen 我们传入一个 callback，这个 callback 有一个参数会传入一个 observable，这个 observable 不是原本的 observable(example) 而是例外事件送出的错误所组成的一个 observable，我们可以对这个由错误所组成的 observable 做操作，等到这次的处理完成后就会重新订阅我们原本的 observable。</p><p>retryWhen <strong>拿来做错误通知</strong></p><h2 id="组播操作运算符"><a href="#组播操作运算符" class="headerlink" title="组播操作运算符"></a>组播操作运算符</h2><h3 id="multicast"><a href="#multicast" class="headerlink" title="multicast"></a>multicast</h3><p>multicast 可以用来挂载 subject 并回传一个可连结(connectable)的 observable</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line">             .take(<span class="number">3</span>)</span><br><span class="line">             .multicast(<span class="keyword">new</span> Rx.Subject());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observerA = &#123;</span><br><span class="line">    next: <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A next: '</span> + value),</span><br><span class="line">    error: <span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A error: '</span> + error),</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A complete!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observerB = &#123;</span><br><span class="line">    next: <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B next: '</span> + value),</span><br><span class="line">    error: <span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B error: '</span> + error),</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B complete!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">source.subscribe(observerA); <span class="comment">// subject.subscribe(observerA)</span></span><br><span class="line"></span><br><span class="line">source.connect(); <span class="comment">// source.subscribe(subject) start</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    source.subscribe(observerB); <span class="comment">// subject.subscribe(observerB)</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>注意： 要把 connect() 回传的 subscription 退订才会真正停止 observable 的执行</p><h3 id="refCount"><a href="#refCount" class="headerlink" title="refCount"></a>refCount</h3><p>通常我们会希望有 observer 订阅时，就立即执行并发送元素，而不要再多执行一个方法(connect)，这时我们就可以用 refCount<br>refCount 必须搭配 multicast 一起使用，他可以建立一个只要有订阅就会自动 connect 的 observable</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line">             .do(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'send: '</span> + x))</span><br><span class="line">             .multicast(<span class="keyword">new</span> Rx.Subject())</span><br><span class="line">             .refCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observerA = &#123;</span><br><span class="line">    next: <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A next: '</span> + value),</span><br><span class="line">    error: <span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A error: '</span> + error),</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A complete!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observerB = &#123;</span><br><span class="line">    next: <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B next: '</span> + value),</span><br><span class="line">    error: <span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B error: '</span> + error),</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B complete!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subscriptionA = source.subscribe(observerA);</span><br><span class="line"><span class="comment">// 订阅数 0 =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subscriptionB;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscriptionB = source.subscribe(observerB);</span><br><span class="line">    <span class="comment">// 订阅数 0 =&gt; 2</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>当 source 一被 observerA 订阅时(订阅数从 0 变成 1)，就会立即执行并发送元素，我们就不需要再额外执行 connect.<br>同样的在退订时只要订阅数变成 0 就会自动停止发送</p><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p>等价于<code>multicast(new Subject())</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subject 的三种变形</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line">             .publishReplay(<span class="number">1</span>)</span><br><span class="line">             .refCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// var source = Rx.Observable.interval(1000)</span></span><br><span class="line"><span class="comment">//             .multicast(new Rx.ReplaySubject(1))</span></span><br><span class="line"><span class="comment">//             .refCount();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line">             .publishBehavior(<span class="number">0</span>)</span><br><span class="line">             .refCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// var source = Rx.Observable.interval(1000)</span></span><br><span class="line"><span class="comment">//             .multicast(new Rx.BehaviorSubject(0))</span></span><br><span class="line"><span class="comment">//             .refCount();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line">             .publishLast()</span><br><span class="line">             .refCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// var source = Rx.Observable.interval(1000)</span></span><br><span class="line"><span class="comment">//             .multicast(new Rx.AsyncSubject(1))</span></span><br><span class="line"><span class="comment">//             .refCount();</span></span><br></pre></td></tr></table></figure><h3 id="share"><a href="#share" class="headerlink" title="share"></a>share</h3><p>等价于 <code>publish + refCount</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line">             .share();</span><br><span class="line"></span><br><span class="line"><span class="comment">// var source = Rx.Observable.interval(1000)</span></span><br><span class="line"><span class="comment">//             .publish()</span></span><br><span class="line"><span class="comment">//             .refCount();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var source = Rx.Observable.interval(1000)</span></span><br><span class="line"><span class="comment">//             .multicast(new Rx.Subject())</span></span><br><span class="line"><span class="comment">//             .refCount();</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>用可视化来理解switchMap, concatMap, flatMap,exhaustMap - <a href="https://segmentfault.com/a/1190000015232015?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015232015?utm_source=tag-newest</a></li><li>学习RxJS操作符 - <a href="https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/switchmap.html" target="_blank" rel="noopener">https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/switchmap.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲解rxjs的操作符, 特别是开发中常用的～&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://u.lovemma.cn/categories/code/"/>
    
    
      <category term="js" scheme="http://u.lovemma.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>First Article</title>
    <link href="http://u.lovemma.cn/passages/hello-world/"/>
    <id>http://u.lovemma.cn/passages/hello-world/</id>
    <published>2020-07-19T00:27:30.126Z</published>
    <updated>2020-07-19T01:29:31.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Old-Blog"><a href="#Old-Blog" class="headerlink" title="Old Blog"></a>Old Blog</h2><p><a href="http://http://lovemma.cn/" target="_blank" rel="noopener">lovemma</a> or <a href="https://angryreid.github.io/" target="_blank" rel="noopener">there</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Old-Blog&quot;&gt;&lt;a href=&quot;#Old-Blog&quot; class=&quot;headerlink&quot; title=&quot;Old Blog&quot;&gt;&lt;/a&gt;Old Blog&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://http://lovemma.cn/&quot; target=&quot;_b
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
